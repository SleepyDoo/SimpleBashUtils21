#include <stdio.h>#include <getopt.h>#include <unistd.h>#include <sys/stat.h>#include <sys/mman.h>#include "s21_grep.h"#include <pcre.h>#include <string.h>#include <fcntl.h>int main(int argc, char * argv[]) {    if (argc > 1) {        extern int optind;        extern char *optarg;        opt options = {0};        char e_template[1024] = {0};        parser(argc, argv, &options, e_template);        reader(argv, options, argc, e_template);    } else {        printf("ERROR! Usage: [OPTION]... PATTERNS [FILE]...\n");    }    return 0;}void parser(int argc, char ** argv, opt * options, char e_template[1024]) {    int opt = 0;    int counter_s = 0;    int * n = &counter_s;    while (opt != -1) {        opt = getopt(argc, argv, "e:ivclnofsh");        if (opt != -1) {            switch (opt) {                case 'e':                    options->e = options->e + 1;                    get_template_e(e_template, n);                    break;                case 'i':                    options->i = 1;                    break;                case 'v':                    options->v = 1;                    break;                case 'c':                    options->c = 1;                    break;                case 'l':                    options->l = 1;                    break;                case 'n':                    options->n = 1;                    break;                case 'o':                    options->o = 1;                    break;                case 'h':                    options->h = 1;                    break;                case 's':                    options->s = 1;                    break;                case 'f':                    options->f = 1;                    break;                default: printf("error in flags\n");            }        }    }}void get_template_e(char template[1024], int *counter_s) {    int counter_t = 0;    int flag = 1;    while (flag) {        if (optarg[counter_t] != '\0') {            template[*counter_s] = optarg[counter_t];        } else {            template[*counter_s] = '|';            flag = 0;        }        counter_t++;        *counter_s = *counter_s + 1;    }}void reader(char ** argv, opt options, int argc, char e_template[1024]) {    int file = 0;    int file_len = 0;    char *file_data;    struct stat statbuf;    const char *template;    const char *err;    int error_offset = 0;    pcre *regular;    template = argv[optind];    int flag_file = 0;    struct stat flag_statbuf;    int flag_file_len = 0;    char *flag_file_data;    if (!options.e && !options.f) {        if (options.i) {            regular = pcre_compile(template, PCRE_CASELESS, &err, &error_offset, NULL);        } else {            regular = pcre_compile(template, 0, &err, &error_offset, NULL);        }    }    if (options.f) {        flag_file = open(argv[optind], O_RDONLY);                if (flag_file > 0) {            fstat(flag_file, &flag_statbuf);            flag_file_len = flag_statbuf.st_size;            if (flag_file_len < 1) {                flag_file = -1;            } else {                flag_file_data = mmap(0, flag_file_len, PROT_READ, MAP_SHARED, flag_file, 0);            }        } else if (!options.s) {            printf("ERROR! No such file!\n");        }    }    int file_count = 0;    int file_counter;    int adder;    while (optind + file_count < argc - 1) {        file_count++;    }    if (options.e) {        file_counter = 0;        adder = 0;        file_count++;    } else {        file_counter = 1;        adder = 1;    }    while (file_counter < file_count + adder && flag_file > -1) {        int matched_lines_count = 0;        file = open(argv[optind + file_counter], O_RDONLY);        if (file >= 0) {            fstat(file, &statbuf);            file_len = statbuf.st_size;            if (options.c && file_len < 1) {                if (file_count > 1) {                    printf("%s:", argv[optind + file_counter]);                }                printf("0\n");            }            if (file_len > 0) {                file_data = mmap(0, file_len, PROT_READ, MAP_SHARED, file, 0);                int ovector[30] = {0};                char line[1024] = {0};                int line_number = 0;                int line_counter = 0;                int temp_c = 0;                int is_file = 1;                int found_line_len = 0;                int l_flag = 1;                int result_num = 0;                int start_offset = 0;                while (file_data[line_counter] > -1 && is_file && l_flag) {                    if (file_data[line_counter] != '\n' && file_data[line_counter] != 0) {                        line[temp_c] = file_data[line_counter];                        temp_c++;                    } else {                        result_num = 0;                        start_offset = 0;                        line_number++;                        if (file_data[line_counter] == '\n' || (file_data[line_counter] == 0 && temp_c != 0)) {                            line[temp_c] = '\n';                        } else if (file_data[line_counter] == '\0' && temp_c == 0) {                            line[temp_c] = 0;                        }                        if (!options.o && !options.e && !options.f) {                            result_num = pcre_exec(regular, NULL, line, 1024, start_offset, 0, ovector, 30);                            if (result_num > 0 && !options.v && !options.l && !options.c) {                                if (file_count > 1 && !options.h) {                                    printf("%s:", argv[optind + file_counter]);                                }                                if (options.n) {                                    printf("%d:", line_number);                                }                                if (line[temp_c] != '\n') {                                    printf("%s\n", line);                                } else {                                    printf("%s", line);                                }                            }                            if (options.v && result_num < 1 && line[temp_c] != 0) {                                if (file_count > 1) {                                    printf("%s:", argv[optind + file_counter]);                                }                                if (line[temp_c] != '\n') {                                    printf("%s\n", line);                                } else {                                    printf("%s", line);                                }                            }                            if (options.l && result_num > 0) {                                printf("%s\n", argv[optind + file_counter]);                                l_flag = 0;                            }                            if (options.c) {                                if (result_num > 0) {                                    matched_lines_count++;                                }                            }                        }                        if (options.f && flag_file > 0) {                            char new_template[512] = {0};                            int f_counter = 0;                            int r_counter = 0;                            int found = 0;                            while (r_counter <= flag_file_len) {                                if (flag_file_data[r_counter] != '\n' && flag_file_data[r_counter] != 0) {                                    new_template[f_counter] = flag_file_data[r_counter];                                    f_counter++;                                } else {                                     if (flag_file_data[r_counter] == '\n') {                                         new_template[f_counter] = '\n';                                     }                                    regular = pcre_compile(new_template, 0, &err, &error_offset, NULL);                                    result_num = pcre_exec(regular, NULL, line, 1024,                                                           start_offset, PCRE_NOTEMPTY, ovector, 30);                                    if (result_num > 0) {                                            if (!found) {                                                if (file_count > 1) {                                                    printf("%s:", argv[optind + file_counter]);                                                }                                                if (line[temp_c] != '\n') {                                                    printf("%s\n", line);                                                } else {                                                    printf("%s", line);                                                }                                            }                                    found = 1;                                    }                                    memset(new_template, '\0', 512);                                    f_counter = 0;                                    pcre_free(regular);                                }                                r_counter++;                            }                        }                                                if (options.e) {                            int e_counter = 0;                            int r_counter = 0;                            char new_template[512] = {0};                                                        while (e_template[r_counter] != '\0') {                                if (e_template[r_counter] == '|') {                                        regular = pcre_compile(new_template, PCRE_UTF8,                                                           &err, &error_offset, NULL);                                        result_num = pcre_exec(regular, NULL, line,                                                           1024, start_offset, 0, ovector, 30);                                        if (result_num > 0) {                                            if (file_count > 1) {                                                printf("%s:", argv[optind + file_counter]);                                            }                                            if (line[temp_c] != '\n') {                                                printf("%s\n", line);                                            } else {                                                printf("%s", line);                                            }                                        }                                    memset(new_template, '\0', 512);                                    e_counter = 0;                                    pcre_free(regular);                                } else {                                    new_template[e_counter] = e_template[r_counter];                                    e_counter++;                                }                                r_counter++;                            }                        }                        int is_l_c = 1;                        while (result_num > -1 && options.o) {                            int counter = 0;                            result_num = pcre_exec(regular, NULL, line, 1024, start_offset, 0, ovector, 30);                            if (result_num > 0) {                                start_offset = ovector[1];                                if (file_count > 1 && is_l_c) {                                        write(1, argv[optind + file_counter], strlen(argv[optind + file_counter]));                                        write(1, ":", 1);                                    }                            }                            while (counter < result_num * 2) {                                if (options.o) {                                    found_line_len = ovector[counter + 1] - ovector[counter];                                    write(1, line + ovector[counter], found_line_len);                                    write(1, "\n", 1);                                }                                counter = counter + 2;                                is_l_c = 0;                            }                        }                        temp_c = 0;                        memset(line, '\0', sizeof(char) * 1024);                    }                    if (file_data[line_counter] == 0) {                        is_file = 0;                    } else {                        line_counter++;                    }                }                if (options.c && file_count > 1) {                    printf("%s:%d\n", argv[optind + file_counter], matched_lines_count);                } else if (options.c && file_count < 2) {                    printf("%d\n", matched_lines_count);                }                close(file);                munmap(file_data, file_len);            }    } else if (!options.s) {        printf("ERROR! Unable to open file\n");    }    file_counter++;}    if (!options.e && !options.f) {        pcre_free(regular);    }    if (flag_file > 0) {    munmap(flag_file_data, flag_file_len);    close(flag_file);    }}